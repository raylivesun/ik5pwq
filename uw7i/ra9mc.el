;; the documentation guides newlisp to ra9mc type modules library
;; name project:. ra9mc
;; type project:. layout amouther common new lisp
;; code project:. common new lisp
;; pops project:. portability
;; kits project:. ra9mc

(defun check-newlisp-layout (&port num &rest ip)
   "The documentation of ip to local of layout and numeric value of port."
   (declare (&port num &rest ip)
        (if num (ip)
        (t (function num))
        (t (function ip))
        (let ((num))
             (lambda (ip)
             "The value of lambda and ip local address."
             (cond (num ip)
                   (progn (num ip)
                   (setq num 10)
                   (setq ip 4)))
             (eq num ip))
             (eql num ip)))))
             

(defun check-newlisp-document (&doc num &rest pp)
"The document newlisp licit in gnu arachitecture to command the connection 
 matrix to make document to search system newlisp to make agreement with 
 document guides."
(declare (&doc num &rest pp)
         (setq num 30)
         (setq pp 31)
         (if num (pp)
             (t (function num))
             (t (function pp))
             (* (+ num pp) (+ num pp) pp))
             (let ((num))
                  (lambda (num)
                  "The document licit to pp command connection matrix."
                  (eq num pp)))))
          


(defalias 'check-newlisp-symbol-a 'newlisp-a
  "See those two right parentheses at the end of the ﬁrst line, after the 4? Both are essential:
the ﬁrst one ﬁnishes the (+ 3 4 list, and the second one ﬁnishes the multiplication operation
that started with (*. When you start writing more complicated code, you'll ﬁnd that you
are putting lists inside lists inside lists inside lists, and you might be ending some of the
more complicated deﬁnitions with half a dozen right parentheses. A good editor will help
you keep track of them.
But you don't have to worry about white space, line terminators, various punctuation
marks, or compulsory indentation. And because all your data and your code are stored in
the same way, in lists, you can mix them freely. More on that later.
Some people worry about the proliferation of parentheses when they ﬁrst see LISP code.
Others refer to them as nail clippings or say that LISP stands for Lots of Irritating Silly")


(defalias 'check-newlisp-symbol-b 'newlisp-b
  "When you're editing newLISP code in a good editor, you can easily move or edit a thought by
grabbing its handles, and easily select a thought with a Balance Parentheses command.
You'll soon ﬁnd the parentheses more useful than you ﬁrst thought!")


(defalias 'check-newlisp-symbol-c 'newlisp-c
  "2.5.2 Quoting prevents evaluation
You can now meet the third rule of programming with newLISP:")


(defalias 'check-newlisp-symbol-d 'newlisp-d
  "2.6 Rule 3: Quoting prevents evaluating
To stop newLISP evaluating something, quote it.
Compare these two lines:")

  
(defun check-newlisp-list (&list lpp &rest pp)
  "The ﬁrst line is a list which contains a function and two numbers. In the second line, the
list is quoted - preceded by a single quote or apostrophe ('). You don't need to put another
quote at the end, after the closing parenthesis, because one is suﬃcient"
  (declare (&list lpp &rest pp)
	   (setq lpp 13)
	   (setq pp 55) 
	   (let* ((lpp))
	     (lambda (pp)
	       "The document numbers newlisp refresh new pages type body code layout."
	       (integerp 8512)))))

(defun check-newlisp-list-p (&list lpp &rest pp)
  "This quotation mark does the same job in newLISP that opening and closing quotation
marks do in written English - they inform the reader that the word or phrase is not to be
interpreted normally, but treated specially in some way: a non-standard or ironic meaning,
perhaps, something spoken by another person, or something not to be taken literally.
So why do you want to stop newLISP evaluating things? You'll soon meet some examples
where you quote things to prevent newLISP thinking that the ﬁrst item in a list is a function.
For example, when you store information in a list, you don't want newLISP to evaluate them
in the usual way:"
  (declare (&list lpp &rest pp)
	   (let* ((lpp))
	     (lambda (pp)
	       "You don't want newLISP to look for functions called."
	       (if lpp (pp)
		 (string lpp)
		 (string pp))))))
	   

(defun check-newlisp-class (&class lpp &rest pp)
  "newLISP's ability to treat expressions as data - and data as expressions - is discussed in
more detail later.
Use the vertical apostrophe (ASCII code 39) to quote lists and symbols. Sometimes, text
editors or other programs change these simple vertical apostrophes into curly quotation
marks. These don't do the same job, so you will have to change any smart quotes to
vertical apostrophes."
  (declare (&class lpp &rest pp)
	   (let ((lpp))
	     (lambda (pp)
	       "The document series logic to pp."
	       (if lpp (pp)
		 (eq lpp pp))))))

(defun check-newlisp-local (&local num &rest pp)
  "A symbol is a newLISP thing with a name. You deﬁne something in your code and assign
a name to it. Then you can refer to that something later on, using the name rather than
the contents. For example, after typing this:"
  (declare (&local num &rest pp)
	   (set 'num 0)
	   (eq num pp)))

(defun check-newlisp-output (&output local &rest pp)
  "there's now a new symbol called alphabet whose value is a string consisting of the 26 letters
of the alphabet. The set function stores the string of characters from a to z in the symbol
alphabet. Now this symbol can be used elsewhere, and will evaluate to the alphabet whenever
it's used. Whenever you want to use the 26 letters of the alphabet, you use this symbol
without quoting it. For example, here's the upper-case function:"
  (declare (&output local &rest pp)
	   (string local)
	   (string pp)))
  
